# 496. Next Greater Element I
- 496. Next Greater Element I [Stack] [Easy]

#### Tags
- [Stack] [Easy]

#### Problem
You are given two arrays (without duplicates) nums1 and nums2 where nums1â€™s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2.

The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.

Example 1:

    Input: nums1 = [4,1,2], nums2 = [1,3,4,2].
    Output: [-1,3,-1]
    Explanation:
        For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.
        For number 1 in the first array, the next greater number for it in the second array is 3.
        For number 2 in the first array, there is no next greater number for it in the second array, so output -1.

Example 2:

    Input: nums1 = [2,4], nums2 = [1,2,3,4].
    Output: [3,-1]
    Explanation:
        For number 2 in the first array, the next greater number for it in the second array is 3.
        For number 4 in the first array, there is no next greater number for it in the second array, so output -1.

**Note**:

1. All elements in nums1 and nums2 are unique.
2. The length of both nums1 and nums2 would not exceed 1000.

#### Solution
``` C++
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& findNums, 
                                   vector<int>& nums) {
        vector<int> result;
        if (findNums.empty() || nums.empty()) return result;
        stack<int> s;
        s.push(nums[0]);
        unordered_map<int, int> m;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] <= s.top())
                s.push(nums[i]);
            else {
                while (!s.empty() && nums[i] > s.top()) {
                    m.insert({s.top(), i});
                    s.pop();
                }
                s.push(nums[i]);
            }
        }
        for (int i = 0; i < findNums.size(); i++) {
            if (m.count(findNums[i]))
                result.push_back(nums[m[findNums[i]]]);
            else
                result.push_back(-1);
        }
        return result;
    }
};
```

#### Notes
- Use Stack, 20181002.

#### Related Problems
- 496. Next Greater Element I [Stack] [Easy]
- 503. Next Greater Element II [Stack] [Medium]
