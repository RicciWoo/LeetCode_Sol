## 4. Median of Two Sorted Arrays
4. Median of Two Sorted Arrays [Binary Search] [Array] [Divide and Conquer] [Hard]

> There are two sorted arrays nums1 and nums2 of size m and n respectively.
> Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
> Example 1:
> nums1 = [1, 3]
> nums2 = [2]
> The median is 2.0
> Example 2:
> nums1 = [1, 2]
> nums2 = [3, 4]
> The median is (2 + 3)/2 = 2.5

### 题目
设有两个已排序数组num1和num2，大小分别为m和n，求两个数组的中位数。总体时间复杂度应该为$O(log(m+n))$.
### 解法
假设A和B的元素个数都大于k/2，我们将A的第k/2个元素（即A[k/2-1]）和B的第k/2个元素（即B[k/2-1]）进行比较，有一下三种情况（为了简化这里先假设k为偶数，所得到的揭露对于k是奇数也是成立的）：
- `A[k/2-1] == B[k/2-1]`
- `A[k/2-1] > B[k/2-1]`
- `A[k/2-1] < B[k/2-1]`
如果`A[k/2-1] < B[k/2-1]`，意味着A[0]到A[k/2-1]的肯定在$A \cup B$的top k元素的范围内，换句话说，A[k/2-1]不可能大于$A \cup B$的第k大元素。
因此，我们可以放心的删除A数组的这k/2个元素。同理，当`A[k/2-1] > B[k/2-1]`时，可以删除B数组的k/2个元素。
当`A[k/2-1] == B[k/2-1]`时，说明找到了第k大的元素，直接返回A[k/2-1]或B[k/2-1]即可。
因此，我们可以用递归函数实现，那么终止的条件是：
- 当A或B是空时，直接返回B[k-1]或A[k-1]；
- 当k=1时，返回min(A[0], B[0])；
- 当A[k/2-1] == B[k/2-1]时，返回A[k/2-1]或B[k/2-1]
时间复杂度$O(log(m+n))$，空间复杂度$O(log(m+n))$

### 代码
``` C++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        const int m = nums1.size();
        const int n = nums2.size();
        int total = m + n;
        if (total & 0x1)
            return find_kth(nums1.begin(), m, nums2.begin(), n, total/2 + 1);
        else
            return (find_kth(nums1.begin(), m, nums2.begin(), n, total/2)
                  + find_kth(nums1.begin(), m, nums2.begin(), n, total/2 + 1)) / 2.0;
    }

private:
    static int find_kth(vector<int>::const_iterator A, int m,
                        vector<int>::const_iterator B, int n, int k) {
        if (m > n) return find_kth(B, n, A, m, k);
        if (m == 0) return *(B + k - 1);
        if (k == 1) return min(*A, *B);
        int ia = min(k/2, m), ib = k - ia;
        if (*(A + ia - 1) < *(B + ib - 1))
            return find_kth(A + ia, m - ia, B, n, k - ia);
        else if (*(A + ia - 1) > *(B + ib - 1))
            return find_kth(A, m, B + ib, n - ib, k - ib);
        else
            return A[ia - 1];
    }
};
```

### 错误与改正
- 代码风格
private:之前空一行

### 相关题目
4. Median of Two Sorted Arrays [Binary Search] [Array] [Divide and Conquer] [Hard]
