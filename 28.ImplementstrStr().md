## 28. Implement strStr()
- 28. Implement strStr() [Two Pointers] [String] [Easy]

#### Tags
- [Two Pointers] [String] [Easy]

#### Problem
Implement strStr().

Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

Example 1:

    Input: haystack = "hello", needle = "ll"
    Output: 2

Example 2:

    Input: haystack = "aaaaa", needle = "bba"
    Output: -1

**Clarification**:

What should we return when needle is an empty string? This is a great question to ask during an interview.

For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().

#### Solution #1
``` C++
class Solution {
public:
    int strStr(string haystack, string needle) {
        if (needle.empty()) return 0;
        if (haystack.empty()) return -1;
        int n = haystack.size() - needle.size() + 1;
        for (int i = 0; i < n; i++) {
            int j = 0;
            for (j = 0; j < needle.size(); j++) {
                if (haystack[i + j] != needle[j]) break;
            }
            if (j == needle.size()) {
                return i;
            }
        }
        return -1;
    }
};
```

#### Time Complexity
- $O(n^2)$

#### Space Complexity
- $O(1)$

#### Notes
- Use Two Pointers, 20181001.

#### Solution #2
``` C++
class Solution {
public:
    int strStr(string haystack, string needle) {
        if (needle.empty()) return 0;
        if (haystack.empty()) return -1;
        
        int BASE = 1000000;
        int m = needle.size();
        
        // 31 ^ m
        int power = 1;
        for (int i = 0; i < m; i++) {
            power = (power * 31) % BASE;
        }
        
        int needleCode = 0;
        for (int i = 0; i < m; i++) {
            needleCode = (needleCode * 31 + needle[i]) % BASE;
        }
        
        int hashCode = 0;
        for (int i = 0; i < haystack.size(); i++) {
            // abc + d
            hashCode = (hashCode * 31 + haystack[i]) % BASE;
            if (i < m - 1) {
                continue;
            }
            
            // abcd - a
            if (i >= m) {
                hashCode -= (haystack[i - m] * power) % BASE;
                if (hashCode < 0) {
                    hashCode += BASE;
                }
            }
            
            // double check the string
            if (hashCode == needleCode) {
                if (haystack.substr(i - m + 1, m) == needle) {
                    return i - m + 1;
                }
            }
        }
        
        return -1;
    }
};
```

#### Time Complexity
- $O(n + m)$

#### Space Complexity
- $O(1)$

#### Notes
- Use Rabin Karp Algorithm, 20181003.

#### Related Problems
- 8. String to Integer (atoi) [Math] [String] [Medium]
- 28. Implement strStr() [Two Pointers] [String] [Easy]
