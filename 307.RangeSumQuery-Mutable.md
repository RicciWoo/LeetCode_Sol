# 307. Range Sum Query - Mutable
- 307. Range Sum Query - Mutable [Binary Indexed Tree] [Segment Tree] [Medium]

#### Tags
- [Binary Indexed Tree] [Segment Tree] [Medium]

#### Problem
Given an integer array nums, find the sum of the elements between indices i and j (i â‰¤ j), inclusive.

The update(i, val) function modifies nums by updating the element at index i to val.

Example:

    Given nums = [1, 3, 5]

    sumRange(0, 2) -> 9
    update(1, 2)
    sumRange(0, 2) -> 8

**Note**:

1. The array is only modifiable by the update function.
2. You may assume the number of calls to update and sumRange function is distributed evenly.

#### Solution
``` C++
class SegmentTreeNode {
public:
    int start, end, sum;
    SegmentTreeNode *left, *right;
    SegmentTreeNode(int start, int end, int sum) {
        this->start = start;
        this->end = end;
        this->sum = sum;
        this->left = this->right = nullptr;
    }
};

class NumArray {
public:
    NumArray(vector<int> nums) {
        if (nums.empty()) {
            return;
        }
        
        root = _build(nums, 0, nums.size() - 1);
    }
    
    void update(int i, int val) {
        if (root == nullptr || 
            i < root->start || i > root->end) {
            return;
        }
        
        _modify(root, i, val);
    }
    
    int sumRange(int i, int j) {
        if (root == nullptr || i > j) {
            return 0;
        }
        
        return _query(root, i, j);
    }
    
private:
    SegmentTreeNode *root = nullptr;
    
    SegmentTreeNode *_build(vector<int> &nums, int start, int end) {
        SegmentTreeNode *root = new SegmentTreeNode(start, end, nums[start]);
        if (start == end) {
            return root;
        }
        
        int mid = start + (end - start) / 2;
        root->left = _build(nums, start, mid);
        root->right = _build(nums, mid + 1, end);
        root->sum = root->left->sum + root->right->sum;
        return root;
    }
    
    int _query(SegmentTreeNode *root, int start, int end) {
        if (start <= root->start && root->end <= end) {
            return root->sum;
        }
        
        int mid = root->start + (root->end - root->start) / 2;
        int result = 0;
        if (start <= mid) {
            result += _query(root->left, start, end);
        }
        if (mid < end) {
            result += _query(root->right, start, end);
        }
        
        return result;
    }
    
    void _modify(SegmentTreeNode *root, int index, int value) {
        if (root->start == index && index == root->end) {
            root->sum = value;
            return;
        }
        
        int mid = root->start + (root->end - root->start) / 2;
        if (root->start <= index && index <= mid) {
            _modify(root->left, index, value);
        }
        if (mid < index && index <= root->end) {
            _modify(root->right, index, value);
        }
        root->sum = root->left->sum + root->right->sum;
    }
};
```

#### Notes
- Use Segment Tree, 20181226.

#### Related Problems
- 303. Range Sum Query - Immutable [Dynamic Programming] [Easy]
- 307. Range Sum Query - Mutable [Binary Indexed Tree] [Segment Tree] [Medium]
- 315. Count of Smaller Numbers After Self [Divide and Conquer] [Binary Indexed Tree] [Segment Tree] [Binary Search Tree] [Hard]
